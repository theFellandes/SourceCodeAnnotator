from dataclasses import dataclass

from Controller.base_controller import BaseController
from Models.SourceCode.python_ast import PythonAST


@dataclass
class PythonController(BaseController):
    def __post_init__(self):
        super().__post_init__()
        self.python_ast = PythonAST(self.source_code_string)

    def get_ast(self):
        return self.python_ast.get_ast()

    def write_ast(self):
        return self.python_ast.write_ast()


    def generate_comment_from_function_name(self):
        list_of_function_names = self.python_ast.get_list_of_function_names()
        list_of_generated_comments = [self.name_analyzer.get_generated_comment(function_name)
                                      for function_name in list_of_function_names]
        return list_of_generated_comments

    def comment_source_code(self):
        """ Returns the commented source code generated by LazyDoc """
        # TODO: self.source_code_string should be manipulated here
        self.source_code_string = self.comment_functions(self.python_ast.get_ast().body)
        return self.source_code_string

    def comment_functions(self, ast_body):
        for child in ast_body:
            if type(child).__name__ == 'FunctionDef':
                self.comment_function(child)

            if hasattr(child, 'body'):
                self.comment_functions(child.body)
        return self.source_code_string

    def comment_function(self, function_def):
        print(self.comment_getter_setter(function_def))
        for statement in function_def.body:
            print(self.stringify_statement(statement))
            print(self.comment_match(statement))

    @staticmethod
    def comment_getter_setter(function_def):
        if function_def.name.startswith('get_'):
            return f"Gets the {function_def.body[0].value.attr} attribute"

        if function_def.name.startswith('set_'):
            return f"Sets the {function_def.body[0].targets[0].attr} attribute"

        if hasattr(function_def, 'decorator_list'):
            for decorator in function_def.decorator_list:
                if hasattr(decorator, 'id') and decorator.id == 'property':
                    return f"Gets the {function_def.name} attribute"
                if hasattr(decorator, 'attr') and decorator.attr == 'setter':
                    return f"Sets the {function_def.name} attribute"

        return ''

    @staticmethod
    def stringify_data_types(data_type, statement):
        match data_type:
            case 'Tuple':
                return f"({statement})"
            case 'List':
                return f"[{statement}]"
            case 'Set':
                return f"{{{statement}}}"

    def stringify_statement(self, statement) -> str:
        left_side = ""
        right_side = ""
        operator = ""

        match type(statement).__name__:
            case 'Assign':
                left_side = self.stringify_statement(statement.targets[0])
                right_side = self.stringify_statement(statement.value)
                operator = "="

            case 'AugAssign':
                left_side = self.stringify_statement(statement.target)
                right_side = self.stringify_statement(statement.value)
                operator = self.python_ast.handle_operators(statement.op)

            case 'Name':
                return statement.id

            case 'Attribute':
                return f'{self.stringify_statement(statement.value)}.{statement.attr}'

            case 'Tuple' | 'List' | 'Set':
                for element in statement.elts:
                    left_side += str(self.stringify_statement(element)) + ", "
                return self.stringify_data_types(type(statement).__name__, left_side.rstrip(', '))

            case 'Subscript':
                return f'{self.stringify_statement(statement.value)}[{self.stringify_statement(statement.slice)}]'

            case 'Slice':
                if statement.step:
                    return f'{self.stringify_statement(statement.lower)}:{self.stringify_statement(statement.upper)}:{self.stringify_statement(statement.step)}'
                return f'{self.stringify_statement(statement.lower)}:{self.stringify_statement(statement.upper)}'

            case 'Constant':
                if type(statement.value).__name__ == 'str':
                    return f"'{statement.value}'"
                return statement.value

            case 'Expr':
                return 'NOT IMPLEMENTED'

            case 'BinOp':
                left_side = self.stringify_statement(statement.left)
                right_side = self.stringify_statement(statement.right)
                operator = self.python_ast.handle_operators(statement.op)

            case 'Call':
                for arg in statement.args:
                    right_side += str(self.stringify_statement(arg)) + ", "
                right_side = right_side.rstrip(', ')
                return f'{self.stringify_statement(statement.func)}({right_side})'

            case 'UnaryOp':
                raise NotImplementedError

        return f"{left_side} {operator} {right_side}"

    def stringify_match_case(self, statement) -> str:
        match type(statement).__name__:
            case 'MatchSequence':
                comment = '['
                for pattern in statement.patterns:
                    comment += f'{self.stringify_match_case(pattern)}, '
                comment = comment.rstrip(', ')
                comment += ']'
                return comment
            case 'MatchValue':
                return f'{self.stringify_statement(statement.value)}'
            case 'MatchSingleton':
                raise NotImplementedError
            case 'MatchOr':
                comment = ''
                for pattern in statement.patterns:
                    comment += f'{self.stringify_match_case(pattern)} | '
                comment = comment.rstrip('| ')
                return comment
        return ''


    def comment_loop(self, statement):
        # TODO: implement finding inner comments
        inner_comments = []
        if type(statement).__name__ == 'For':
            comment = f'Iterates over {self.stringify_statement(statement.iter)}'
            return comment
        if type(statement).__name__ == 'While':
            comment = f'Loops while {self.stringify_statement(statement.test)}'
            return comment
        return ''

    def comment_match(self, statement):
        # TODO: add inner statement
        if type(statement).__name__ == 'Match':
            comment = f'If {self.stringify_statement(statement.subject)} '
            for match_case in statement.cases:
                comment += f'matches {self.stringify_match_case(match_case.pattern)} DO SOMETHING or '
            comment = comment.rstrip('or ')
            return comment
        return ''



    def recursive_test(self, ast_body):
        raise NotImplementedError
