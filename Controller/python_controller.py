from dataclasses import dataclass

from Controller.base_controller import BaseController
from Models.SourceCode.python_ast import PythonAST


@dataclass
class PythonController(BaseController):
    def __post_init__(self):
        super().__post_init__()
        self.python_ast = PythonAST(self.source_code_string)

    def get_ast(self):
        return self.python_ast.get_ast()

    def write_ast(self):
        return self.python_ast.write_ast()

    def generate_comment_from_function_name(self):
        list_of_function_names = self.python_ast.get_list_of_function_names()
        list_of_generated_comments = [self.name_analyzer.get_generated_comment(function_name)
                                      for function_name in list_of_function_names]
        return list_of_generated_comments

    def comment_source_code(self):
        """ Returns the commented source code generated by LazyDoc """
        # TODO: self.source_code_string should be manipulated here
        self.source_code_string = self.comment_functions(self.python_ast.get_ast().body)
        return self.source_code_string

    def comment_functions(self, ast_body):
        for child in ast_body:
            if type(child).__name__ == 'FunctionDef':
                self.comment_function(child)

            if hasattr(child, 'body'):
                self.comment_functions(child.body)
        return self.source_code_string

    def comment_function(self, function_def):
        # print(self.comment_getter_setter(function_def))
        for statement in function_def.body:
            if type(statement).__name__ == 'Expr':
                continue
            # print(self.stringify_statement(statement))
            # print(self.comment_match(statement))
            # print(self.comment_if(statement))
            print(self.comment_normal_line(statement))

    @staticmethod
    def comment_getter_setter(function_def):
        if function_def.name.startswith('get_'):
            return f"Gets the {function_def.body[0].value.attr} attribute"

        if function_def.name.startswith('set_'):
            return f"Sets the {function_def.body[0].targets[0].attr} attribute"

        if hasattr(function_def, 'decorator_list'):
            for decorator in function_def.decorator_list:
                if hasattr(decorator, 'id') and decorator.id == 'property':
                    return f"Gets the {function_def.name} attribute"
                if hasattr(decorator, 'attr') and decorator.attr == 'setter':
                    return f"Sets the {function_def.name} attribute"

        return ''

    @staticmethod
    def stringify_data_types(data_type, statement):
        match data_type:
            case 'Tuple':
                return f"({statement})"
            case 'List':
                return f"[{statement}]"
            case 'Set':
                return f"{{{statement}}}"

    def stringify_statement(self, statement) -> str:
        left_side = ""
        right_side = ""
        operator = ""

        match type(statement).__name__:
            case 'Assign':
                left_side = self.stringify_statement(statement.targets[0])
                right_side = self.stringify_statement(statement.value)
                operator = "="

            case 'AugAssign':
                left_side = self.stringify_statement(statement.target)
                right_side = self.stringify_statement(statement.value)
                operator = self.python_ast.handle_operators(statement.op)

            case 'Name':
                return statement.id

            case 'Attribute':
                return f'{self.stringify_statement(statement.value)}.{statement.attr}'

            case 'Tuple' | 'List' | 'Set':
                for element in statement.elts:
                    left_side += str(self.stringify_statement(element)) + ", "
                return self.stringify_data_types(type(statement).__name__, left_side.rstrip(', '))

            case 'Subscript':
                return f'{self.stringify_statement(statement.value)}[{self.stringify_statement(statement.slice)}]'

            case 'Slice':
                if statement.step:
                    return f'{self.stringify_statement(statement.lower)}:{self.stringify_statement(statement.upper)}:{self.stringify_statement(statement.step)}'
                return f'{self.stringify_statement(statement.lower)}:{self.stringify_statement(statement.upper)}'

            case 'Constant':
                if type(statement.value).__name__ == 'str':
                    return f"'{statement.value}'"
                return statement.value

            case 'Expr':
                return self.stringify_statement(statement.value)

            case 'BinOp':
                left_side = self.stringify_statement(statement.left)
                right_side = self.stringify_statement(statement.right)
                operator = self.python_ast.handle_operators(statement.op)

            case 'Compare':
                comment = self.stringify_statement(statement.left)
                for op, comparator in zip(statement.ops, statement.comparators):
                    comment += f' {self.python_ast.handle_operators(op)} {self.stringify_statement(comparator)}'
                return comment

            case 'BoolOp':
                left_side = self.stringify_statement(statement.values[0])
                right_side = self.stringify_statement(statement.values[1])
                operator = self.python_ast.handle_operators(statement.op)

            case 'Call':
                for arg in statement.args:
                    right_side += str(self.stringify_statement(arg)) + ", "
                right_side = right_side.rstrip(', ')
                return f'{self.stringify_statement(statement.func)}({right_side})'

            case 'UnaryOp':
                return f'{self.python_ast.handle_operators(statement.op)} {self.stringify_statement(statement.operand)}'

        return f"{left_side} {operator} {right_side}"

    def stringify_match_case(self, statement) -> str:
        match type(statement).__name__:
            case 'MatchSequence':
                comment = '['
                for pattern in statement.patterns:
                    comment += f'{self.stringify_match_case(pattern)}, '
                comment = comment.rstrip(', ')
                comment += ']'
                return comment
            case 'MatchValue':
                return f'{self.stringify_statement(statement.value)}'
            case 'MatchSingleton':
                raise NotImplementedError
            case 'MatchOr':
                comment = ''
                for pattern in statement.patterns:
                    comment += f'{self.stringify_match_case(pattern)} | '
                comment = comment.rstrip('| ')
                return comment
        return ''

    def comment_loop(self, statement):
        # TODO: implement finding inner comments
        inner_comments = []
        if type(statement).__name__ == 'For':
            comment = f'Iterates over {self.stringify_statement(statement.iter)}'
            return comment
        if type(statement).__name__ == 'While':
            comment = f'Loops while {self.stringify_statement(statement.test)}'
            return comment
        return ''

    def comment_if(self, statement):
        comment = ''
        if type(statement).__name__ == 'If':
            comment = f'Checks if {self.stringify_statement(statement.test)}: INNER STATEMENT'

            el = statement
            while el.orelse:
                el = el.orelse[0]
                if not hasattr(el, 'orelse'):
                    comment += f'; else INNER STATEMENT'
                    break
                comment += f'; or if {self.stringify_statement(el.test)}: INNER STATEMENT'
        return comment

    def comment_match(self, statement):
        # TODO: add inner statement
        if type(statement).__name__ == 'Match':
            comment = f'If {self.stringify_statement(statement.subject)} '
            for match_case in statement.cases:
                comment += f'matches {self.stringify_match_case(match_case.pattern)} DO SOMETHING or '
            comment = comment.rstrip('or ')
            return comment
        return ''

    def comment_normal_line(self, statement):
        if type(statement).__name__ == 'Assign':
            return f'Assigns {self.stringify_statement(statement.value)} to {self.stringify_statement(statement.targets[0])} '
        elif type(statement).__name__ == 'Expr':
            if type(statement.value).__name__ == 'Call':
                return f'Calls the {self.stringify_statement(statement.value)} '
        elif type(statement).__name__ == 'AugAssign':
            match type(statement).__name__:
                case 'Add':
                    return f'Increments {self.stringify_statement(statement.value)} by {self.stringify_statement(statement.targets[0])} '
                case 'Sub':
                    return f'Subtracts {self.stringify_statement(statement.value)} from {self.stringify_statement(statement.targets[0])} '
                case 'Mult':
                    return f'Markiplies {self.stringify_statement(statement.value)} with {self.stringify_statement(statement.targets[0])} '
                case 'Div' | 'FloorDiv':
                    return f'Divides {self.stringify_statement(statement.value)} by {self.stringify_statement(statement.targets[0])} '
                case 'Mod':
                    return f'Updates the value of {self.stringify_statement(statement.value)} by taking its modulus with {self.stringify_statement(statement.targets[0])} '
                case 'Pow':
                    return f'Raises {self.stringify_statement(statement.value)} to the power of {self.stringify_statement(statement.targets[0])} '
        elif type(statement).__name__ == "Return":
            return f'Returns {self.stringify_statement(statement.value)} '
        return ''

    def recursive_test(self, ast_body):
        raise NotImplementedError
